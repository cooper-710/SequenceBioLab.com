{% extends "base.html" %}

{% block title %}Player Matchups - Sequence{% endblock %}

{% block extra_head %}
<style>
.content-wrapper {
    max-width: 1200px;
    margin: 0 auto;
}

.search-section {
    background: var(--color-layer-card);
    border-radius: 12px;
    padding: 32px;
    margin-bottom: 32px;
    border: 1px solid var(--color-layer-border);
    box-shadow: var(--shadow-elevated);
}

.form-group {
    margin-bottom: 1.5rem;
}

.form-group label {
    display: block;
    margin-bottom: 0.75rem;
    font-weight: 600;
    color: var(--color-text-primary);
    font-size: 14px;
}

.form-group input[type="number"], .form-group select {
    width: 100%;
    padding: 16px 20px;
    border: 1px solid var(--color-border);
    border-radius: 10px;
    background: var(--color-surface);
    color: var(--color-text-primary);
    font-size: 16px;
    transition: all 0.3s ease;
    box-shadow: inset 0 2px 4px rgba(15, 23, 42, 0.08);
}

.form-group input[type="number"]:focus, .form-group select:focus {
    outline: none;
    border-color: var(--color-accent);
    background: color-mix(in srgb, var(--color-surface) 92%, var(--color-page-bg));
    box-shadow: 0 0 0 3px var(--color-accent-soft);
    transform: translateY(-1px);
}

.search-input-wrapper {
    position: relative;
    width: 100%;
}

.search-input {
    width: 100%;
    padding: 16px 20px;
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: 10px;
    color: var(--color-text-primary);
    font-size: 16px;
    transition: all 0.3s ease;
    box-shadow: inset 0 2px 4px rgba(15, 23, 42, 0.08);
}

.search-input::placeholder {
    color: var(--color-text-muted);
}

.search-input:focus {
    outline: none;
    border-color: var(--color-accent);
    background: color-mix(in srgb, var(--color-surface) 92%, var(--color-page-bg));
    box-shadow: 0 0 0 3px var(--color-accent-soft);
    transform: translateY(-1px);
}

.search-suggestions {
    position: absolute;
    top: calc(100% + 4px);
    left: 0;
    right: 0;
    background: var(--color-surface);
    border: 1px solid var(--color-layer-border);
    border-radius: 0 0 10px 10px;
    max-height: 300px;
    overflow-y: auto;
    z-index: 100;
    box-shadow: var(--shadow-elevated);
    backdrop-filter: blur(10px);
}

.suggestion-item {
    padding: 12px 20px;
    color: var(--color-text-primary);
    cursor: pointer;
    transition: background 0.2s ease;
    border-bottom: 1px solid var(--color-border);
}

.suggestion-item:last-child {
    border-bottom: none;
}

.suggestion-item:hover {
    background: var(--color-layer-soft);
}

.suggestion-item:active {
    background: var(--color-layer-soft);
}

.search-btn {
    background: linear-gradient(135deg, var(--color-accent), var(--color-accent-bright));
    color: var(--color-text-inverse);
    border: none;
    padding: 16px 32px;
    border-radius: 10px;
    cursor: pointer;
    font-weight: 600;
    font-size: 16px;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(255, 127, 0, 0.3);
}

.search-btn:hover {
    background: linear-gradient(135deg, var(--color-accent-bright), var(--color-accent-glow));
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(255, 127, 0, 0.4);
}

.search-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 8px rgba(255, 127, 0, 0.3);
}

.results-section {
    display: none;
}

.summary-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 1rem;
    margin-bottom: 2rem;
}

.stat-card {
    background: var(--color-layer-card);
    padding: 1.5rem;
    border-radius: 10px;
    text-align: center;
    border: 1px solid var(--color-layer-border);
    box-shadow: var(--shadow-floating);
}

.stat-value {
    font-size: 2rem;
    font-weight: bold;
    color: var(--color-accent);
}

.stat-label {
    color: var(--color-text-secondary);
    margin-top: 0.5rem;
    font-size: 0.9rem;
}

.at-bats-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.at-bat-card {
    background: var(--color-layer-card);
    padding: 1.75rem;
    border-radius: 12px;
    border: 1px solid var(--color-layer-border);
    box-shadow: var(--shadow-floating);
    margin-bottom: 1.5rem;
}

.at-bat-header {
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 2px solid var(--color-layer-border);
}

.at-bat-meta {
    display: flex;
    gap: 1rem;
    align-items: center;
    flex-wrap: wrap;
}

.at-bat-date {
    font-size: 0.95rem;
    color: var(--color-text-secondary);
}

.at-bat-number {
    font-size: 0.95rem;
    font-weight: 600;
    color: var(--color-text-primary);
}

.pitches-timeline {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.timeline-label {
    font-size: 0.85rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--color-text-secondary);
    text-align: center;
}

.pitches-sequence {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 1rem;
    background: linear-gradient(to right, var(--color-layer-base), var(--color-layer-card));
    border-radius: 10px;
    border: 1px solid var(--color-layer-border);
    position: relative;
}

.pitch-step {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.5rem 0.75rem;
    background: var(--color-layer-card);
    border-radius: 6px;
    border: 1px solid var(--color-layer-border);
    transition: all 0.2s ease;
    position: relative;
    width: 100%;
    min-height: 2.5rem;
    box-sizing: border-box;
}

.pitch-step:hover {
    border-color: var(--color-accent);
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

.pitch-step.pitch-full-count {
    border-color: var(--color-accent);
    background: var(--color-accent-soft);
}

.pitch-step.pitch-final {
    border-color: var(--color-accent);
    border-width: 2px;
    box-shadow: 0 0 0 2px var(--color-accent-soft);
}

.pitch-number {
    font-size: 0.7rem;
    font-weight: 600;
    color: var(--color-text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    min-width: 2.5rem;
    flex-shrink: 0;
}

.pitch-count-badge {
    font-weight: 700;
    color: var(--color-accent);
    min-width: 2.5rem;
    text-align: center;
    padding: 0.25rem 0.5rem;
    background: var(--color-accent-soft);
    border-radius: 4px;
    font-size: 0.8rem;
    flex-shrink: 0;
}

.pitch-count-badge.count-full {
    background: var(--color-accent);
    color: white;
    animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.8; }
}

.pitch-info {
    display: flex;
    flex-direction: column;
    gap: 0.15rem;
    flex: 1;
    min-width: 0;
}

.pitch-video-link {
    margin-left: auto;
    color: var(--color-accent);
    opacity: 0.7;
    transition: all 0.2s ease;
    padding: 0.25rem 0.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    text-decoration: none;
    flex-shrink: 0;
    border-radius: 4px;
}

.pitch-video-link:hover {
    opacity: 1;
    color: var(--color-accent);
    background: var(--color-accent-soft);
    transform: scale(1.05);
}

.pitch-type {
    font-weight: 600;
    color: var(--color-text-primary);
    font-size: 0.8rem;
}

.pitch-outcome-badge {
    display: inline-block;
    padding: 0.25rem 0.75rem;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 600;
    margin-top: 0.25rem;
    align-self: flex-start;
    text-transform: capitalize;
}

.pitch-outcome-badge.hit {
    background: #2d5016;
    color: #90ee90;
}

.pitch-outcome-badge.home-run {
    background: #4a2d00;
    color: #ffd700;
}

.pitch-outcome-badge.strikeout {
    background: #3a1f1f;
    color: #ff6b6b;
}

.pitch-outcome-badge.walk {
    background: #1f2d3a;
    color: #87ceeb;
}

.pitch-description {
    color: var(--color-text-secondary);
    font-size: 0.7rem;
    font-style: italic;
}

.pitch-description.pitch-strike {
    color: #ff6b6b;
}

.pitch-description.pitch-ball {
    color: #4ecdc4;
}

.pitch-description.pitch-contact {
    color: var(--color-accent);
}

.pitches-visualization {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    margin: 1.5rem 0;
    padding: 0;
    align-items: start;
    width: 100%;
    box-sizing: border-box;
}

.pitches-timeline {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    width: 100%;
    min-width: 0;
}

.strike-zone-container {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    align-items: center;
    width: 100%;
    min-width: 0;
}

.strike-zone-label {
    font-size: 0.85rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--color-text-secondary);
    text-align: center;
    width: 100%;
}

.strike-zone-legend {
    display: flex;
    gap: 1rem;
    justify-content: center;
    align-items: center;
    font-size: 0.7rem;
    color: var(--color-text-secondary);
    margin-top: 0.5rem;
}

.strike-zone-legend-item {
    display: flex;
    align-items: center;
    gap: 0.4rem;
}

.strike-zone-legend-circle {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    border: 2px solid var(--color-text-secondary);
}

.strike-zone-legend-circle.filled {
    background-color: var(--color-text-secondary);
    border-color: var(--color-text-secondary);
}

.strike-zone-legend-circle.outlined {
    background-color: transparent;
}

.strike-zone-pov {
    font-size: 0.65rem;
    font-weight: 500;
    color: var(--color-text-secondary);
    text-align: center;
    opacity: 0.7;
    margin-top: 0.25rem;
    margin-bottom: 0.5rem;
    font-style: italic;
}

.combined-strike-zone {
    width: 100%;
    max-width: 350px;
    margin: 0 auto;
    display: block;
    height: 350px;
    background: linear-gradient(135deg, var(--color-layer-base) 0%, var(--color-layer-card) 100%);
    border-radius: 12px;
    border: 2px solid var(--color-layer-border);
    padding: 1.25rem;
    margin: 0 auto;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.05);
    position: relative;
    overflow: hidden;
}

.combined-strike-zone::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.03) 0%, transparent 70%);
    pointer-events: none;
}

.strike-zone-wrapper {
    position: relative;
    width: 100%;
    display: inline-block;
}

.pitch-tooltip {
    position: fixed;
    background: var(--color-layer-card);
    border: 1px solid var(--color-layer-border);
    border-radius: 8px;
    padding: 0.75rem;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    z-index: 1000;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    min-width: 160px;
    font-size: 0.8rem;
}

.pitch-tooltip.show {
    opacity: 1;
}

.pitch-tooltip-header {
    font-weight: 600;
    color: var(--color-accent);
    margin-bottom: 0.5rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--color-layer-border);
    text-transform: uppercase;
    font-size: 0.75rem;
    letter-spacing: 0.5px;
}

.pitch-tooltip-metric {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.35rem;
    color: var(--color-text-primary);
}

.pitch-tooltip-metric:last-child {
    margin-bottom: 0;
}

.pitch-tooltip-label {
    color: var(--color-text-secondary);
    font-weight: 500;
}

.pitch-tooltip-value {
    color: var(--color-text-primary);
    font-weight: 600;
}

.pitch-marker-group circle {
    transition: r 0.2s ease;
}

.strike-zone-missing {
    width: 100%;
    max-width: 300px;
    height: 300px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.9rem;
    color: var(--color-text-secondary);
    background: var(--color-layer-base);
    border-radius: 10px;
    border: 2px solid var(--color-layer-border);
    text-align: center;
    padding: 1rem;
    margin: 0 auto;
    font-style: italic;
}

@media (max-width: 768px) {
    .pitches-visualization {
        grid-template-columns: 1fr;
        gap: 1.5rem;
        margin: 1.5rem 0;
        padding: 0;
        width: 100%;
        box-sizing: border-box;
    }
    
    .combined-strike-zone {
        max-width: 100%;
    }
}


.at-bat-outcome {
    margin-top: 1.5rem;
    padding-top: 1.5rem;
    border-top: 2px solid var(--color-layer-border);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.75rem;
    background: linear-gradient(to right, transparent, var(--color-layer-base), transparent);
    padding: 1.5rem;
    border-radius: 8px;
}

.outcome-label {
    font-size: 0.85rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--color-text-secondary);
}

.outcome-badge {
    font-size: 1.25rem;
    font-weight: 700;
    padding: 0.75rem 1.5rem;
    border-radius: 8px;
    text-align: center;
    min-width: 150px;
}

.loading {
    text-align: center;
    padding: 2rem;
    color: var(--color-text-secondary);
}

.error {
    background: var(--color-danger-soft);
    color: var(--color-danger);
    padding: 1rem;
    border-radius: 8px;
    margin-bottom: 1rem;
    border: 1px solid var(--color-danger-border);
}

.page-title {
    margin-bottom: 0.5rem;
    color: var(--color-accent);
    font-size: clamp(2rem, 4vw, 2.75rem);
    font-weight: 800;
}

.page-subtitle {
    color: var(--color-text-secondary);
    margin-bottom: 2rem;
    font-size: 1rem;
}

.matchup-title {
    margin-bottom: 1rem;
    color: var(--color-text-primary);
    font-size: 1.5rem;
    font-weight: 700;
}

.outcome-badge {
    display: inline-block;
    padding: 0.25rem 0.75rem;
    border-radius: 4px;
    font-size: 0.9rem;
    font-weight: 600;
    text-transform: capitalize;
}

.outcome-badge.hit {
    background: #2d5016;
    color: #90ee90;
}

.outcome-badge.home-run {
    background: #4a2d00;
    color: #ffd700;
}

.outcome-badge.strikeout {
    background: #3a1f1f;
    color: #ff6b6b;
}

.outcome-badge.walk {
    background: #1f2d3a;
    color: #87ceeb;
}

.season-selector-wrapper {
    margin-top: 0.5rem;
}

.toggle-seasons-btn {
    background: var(--color-surface);
    border: 2px solid var(--color-border);
    border-radius: 8px;
    color: var(--color-text-primary);
    padding: 10px 18px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    margin-bottom: 12px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.toggle-seasons-btn:hover {
    background: color-mix(in srgb, var(--color-surface) 85%, var(--color-main-bg));
    border-color: var(--color-accent);
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.toggle-seasons-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.season-checkboxes {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.season-checkbox-item {
    position: relative;
}

.season-checkbox-item input[type="checkbox"].season-checkbox {
    position: absolute;
    opacity: 0;
    cursor: pointer;
    width: 0;
    height: 0;
}

.season-checkbox-item label.season-label {
    display: inline-block;
    padding: 10px 18px;
    background: linear-gradient(145deg, var(--color-surface), color-mix(in srgb, var(--color-surface) 90%, var(--color-main-bg)));
    border: 2px solid var(--color-border);
    border-radius: 8px;
    color: var(--color-text-secondary);
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    margin: 0;
    user-select: none;
    transition: all 0.3s ease;
    min-width: 70px;
    text-align: center;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.season-checkbox-item label.season-label:hover {
    background: linear-gradient(145deg, color-mix(in srgb, var(--color-surface) 85%, var(--color-main-bg)), var(--color-surface));
    border-color: var(--color-border-strong);
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.season-checkbox-item input[type="checkbox"].season-checkbox:checked + label.season-label {
    background: linear-gradient(145deg, var(--color-accent), var(--color-accent-bright));
    border-color: var(--color-accent);
    color: var(--color-text-primary);
    font-weight: 700;
    box-shadow: 0 4px 12px rgba(255, 127, 0, 0.4);
    transform: translateY(-2px);
}

.season-checkbox-item input[type="checkbox"].season-checkbox:checked + label.season-label:hover {
    background: linear-gradient(145deg, var(--color-accent-bright), var(--color-accent));
    box-shadow: 0 6px 16px rgba(255, 127, 0, 0.5);
}

@media (max-width: 768px) {
    .search-section {
        padding: 24px 20px;
    }
    
    .at-bat-header {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .season-checkboxes {
        gap: 6px;
    }
    
    .season-checkbox-item label.season-label {
        padding: 8px 12px;
        font-size: 12px;
        min-width: 60px;
    }
}
</style>
{% endblock %}

{% block content %}
<div class="page-container">
    <header class="section-hero">
        <div class="section-hero-heading">
            <h1 class="hero-content">Player Matchups</h1>
        </div>
    </header>

    <div class="content-wrapper">
    
    <div class="search-section">
        <form id="matchupForm">
            <div class="form-group">
                <label for="playerName">Player 1</label>
                <div class="search-input-wrapper" style="position: relative;">
                    <input 
                        type="text" 
                        id="playerName" 
                        name="player" 
                        class="search-input" 
                        placeholder="Enter player name (e.g., Pete Alonso)" 
                        autocomplete="off"
                        required
                    >
                    <div id="player1Suggestions" class="search-suggestions" style="display: none; position: absolute; top: 100%; left: 0; right: 0; z-index: 100;"></div>
                </div>
            </div>
            
            <div class="form-group">
                <label for="opponentName">Player 2</label>
                <div class="search-input-wrapper" style="position: relative;">
                    <input 
                        type="text" 
                        id="opponentName" 
                        name="opponent" 
                        class="search-input" 
                        placeholder="Enter player name (e.g., Paul Skenes)" 
                        autocomplete="off"
                        required
                    >
                    <div id="player2Suggestions" class="search-suggestions" style="display: none; position: absolute; top: 100%; left: 0; right: 0; z-index: 100;"></div>
                </div>
            </div>
            
            <div id="roleError" class="error" style="display: none; margin-bottom: 1rem;"></div>
            <div id="roleInfo" style="display: none; margin-bottom: 1rem; padding: 0.75rem; background: var(--color-layer-soft); border-radius: 8px; border: 1px solid var(--color-layer-border); color: var(--color-text-primary);">
                <strong>Detected Roles:</strong> <span id="roleInfoText"></span>
            </div>
            
            <div class="form-group">
                <label>Seasons (optional - leave empty for last 3 years)</label>
                <div class="season-selector-wrapper">
                    <button type="button" id="toggleAllSeasons" class="toggle-seasons-btn">Select All</button>
                    <div class="season-checkboxes" id="seasonCheckboxes"></div>
                </div>
            </div>
            
            <button type="submit" class="search-btn">
                Generate Matchup
            </button>
        </form>
    </div>
    
    <div id="results" class="results-section">
        <div id="errorMessage" class="error" style="display: none;"></div>
        <div id="loading" class="loading" style="display: none;">
            <i class="fas fa-spinner fa-spin"></i> Loading matchup data...
        </div>
        
        <div id="summarySection" style="display: none;">
            <h2 class="matchup-title">Summary Statistics</h2>
            <div class="summary-stats" id="summaryStats"></div>
        </div>
        
        <div id="debugSection" style="display: none; margin-top: 2rem; padding: 1rem; background: var(--color-layer-soft); border-radius: 8px; border: 1px solid var(--color-layer-border);">
            <h3 class="matchup-title" style="font-size: 1.1rem; margin-bottom: 1rem; color: var(--color-text-primary);">Debug Information (Why Stats Might Be Incorrect)</h3>
            <div id="debugInfo" style="color: var(--color-text-secondary); font-family: monospace; font-size: 0.9rem; line-height: 1.6;"></div>
        </div>
        
        <div id="atBatsSection" style="display: none;">
            <h2 class="matchup-title">At-Bat History</h2>
            <div class="at-bats-list" id="atBatsList"></div>
        </div>
    </div>
    </div>
</div>

<script>
function getOutcomeClass(outcome) {
    if (!outcome) return '';
    const outcomeLower = outcome.toLowerCase();
    if (outcomeLower.includes('home_run') || outcomeLower.includes('home run')) {
        return 'home-run';
    }
    if (outcomeLower.includes('single') || outcomeLower.includes('double') || outcomeLower.includes('triple')) {
        return 'hit';
    }
    if (outcomeLower.includes('strikeout') || outcomeLower.includes('strike out')) {
        return 'strikeout';
    }
    if (outcomeLower.includes('walk') || outcomeLower.includes('hit_by_pitch')) {
        return 'walk';
    }
    return '';
}

function formatOutcome(outcome) {
    if (!outcome) return 'Unknown';
    // Convert snake_case to Title Case
    return outcome.split('_').map(word => 
        word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    ).join(' ');
}

function formatDate(dateStr) {
    if (!dateStr) return 'Unknown';
    try {
        // Parse date string (format: YYYY-MM-DD) as local date to avoid timezone issues
        // If it's just a date string without time, parse it as local date
        if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
            // Parse as local date (YYYY-MM-DD format)
            const [year, month, day] = dateStr.split('-').map(Number);
            const date = new Date(year, month - 1, day); // month is 0-indexed
            return date.toLocaleDateString('en-US', { 
                year: 'numeric', 
                month: 'short', 
                day: 'numeric' 
            });
        } else {
            // For other formats, use standard Date parsing
            const date = new Date(dateStr);
            return date.toLocaleDateString('en-US', { 
                year: 'numeric', 
                month: 'short', 
                day: 'numeric' 
            });
        }
    } catch (e) {
        return dateStr;
    }
}

let player1Type = null;
let player2Type = null;
let player1SearchTimeout = null;
let player2SearchTimeout = null;

function normalizePlayerName(name) {
    if (!name) return '';
    return name.normalize("NFD").replace(/\p{Diacritic}/gu, '');
}

// Search for players (Player 1)
async function searchPlayers1() {
    const searchInput = document.getElementById('playerName');
    if (!searchInput) return;
    
    const searchTerm = searchInput.value.trim();
    const normalizedTerm = normalizePlayerName(searchTerm);
    const suggestionsDiv = document.getElementById('player1Suggestions');
    
    if (!normalizedTerm || normalizedTerm.length < 2) {
        if (suggestionsDiv) suggestionsDiv.style.display = 'none';
        return;
    }
    
    try {
        const response = await fetch(`/api/csv/search?q=${encodeURIComponent(normalizedTerm)}`);
        const data = await response.json();
        
        if (data.error || !data.players || data.players.length === 0) {
            if (suggestionsDiv) suggestionsDiv.style.display = 'none';
            return;
        }
        
        const players = data.players || [];
        
        // Show suggestions
        suggestionsDiv.innerHTML = players.slice(0, 10).map((player, idx) => 
            `<div class="suggestion-item" data-player-name="${player.name.replace(/"/g, '&quot;')}" data-index="${idx}">${player.name}</div>`
        ).join('');
        suggestionsDiv.style.display = 'block';
        
        // Add click handlers to suggestions
        suggestionsDiv.querySelectorAll('.suggestion-item').forEach(item => {
            item.addEventListener('click', function() {
                const playerName = this.getAttribute('data-player-name');
                searchInput.value = playerName;
                suggestionsDiv.style.display = 'none';
                // Clear any pending detection timeout
                if (detectTimeout1) clearTimeout(detectTimeout1);
                // Trigger player type detection immediately
                detectPlayerType(playerName.trim(), 1);
            });
        });
    } catch (error) {
        console.error('Search error:', error);
        if (suggestionsDiv) suggestionsDiv.style.display = 'none';
    }
}

// Search for players (Player 2)
async function searchPlayers2() {
    const searchInput = document.getElementById('opponentName');
    if (!searchInput) return;
    
    const searchTerm = searchInput.value.trim();
    const normalizedTerm = normalizePlayerName(searchTerm);
    const suggestionsDiv = document.getElementById('player2Suggestions');
    
    if (!normalizedTerm || normalizedTerm.length < 2) {
        if (suggestionsDiv) suggestionsDiv.style.display = 'none';
        return;
    }
    
    try {
        const response = await fetch(`/api/csv/search?q=${encodeURIComponent(normalizedTerm)}`);
        const data = await response.json();
        
        if (data.error || !data.players || data.players.length === 0) {
            if (suggestionsDiv) suggestionsDiv.style.display = 'none';
            return;
        }
        
        const players = data.players || [];
        
        // Show suggestions
        suggestionsDiv.innerHTML = players.slice(0, 10).map((player, idx) => 
            `<div class="suggestion-item" data-player-name="${player.name.replace(/"/g, '&quot;')}" data-index="${idx}">${player.name}</div>`
        ).join('');
        suggestionsDiv.style.display = 'block';
        
        // Add click handlers to suggestions
        suggestionsDiv.querySelectorAll('.suggestion-item').forEach(item => {
            item.addEventListener('click', function() {
                const playerName = this.getAttribute('data-player-name');
                searchInput.value = playerName;
                suggestionsDiv.style.display = 'none';
                // Clear any pending detection timeout
                if (detectTimeout2) clearTimeout(detectTimeout2);
                // Trigger player type detection immediately
                detectPlayerType(playerName.trim(), 2);
            });
        });
    } catch (error) {
        console.error('Search error:', error);
        if (suggestionsDiv) suggestionsDiv.style.display = 'none';
    }
}

async function detectPlayerType(playerName, playerNumber) {
    if (!playerName || playerName.trim().length < 3) {
        if (playerNumber === 1) player1Type = null;
        if (playerNumber === 2) player2Type = null;
        updateRoleInfo();
        updateAvailableSeasons();
        return null;
    }
    
    try {
        const response = await fetch(`/api/player-type?player=${encodeURIComponent(playerName)}`);
        if (response.ok) {
            const data = await response.json();
            const isPitcher = data.is_pitcher === true;
            
            if (playerNumber === 1) {
                player1Type = isPitcher ? 'pitcher' : 'batter';
            } else {
                player2Type = isPitcher ? 'pitcher' : 'batter';
            }
            
            updateRoleInfo();
            // Always try to update seasons when a type is detected
            // This ensures it updates as soon as both types are available
            updateAvailableSeasons();
            return isPitcher ? 'pitcher' : 'batter';
        }
    } catch (error) {
        console.warn('Error detecting player type:', error);
    }
    
    return null;
}

let seasonsUpdateTimeout = null; // Debounce timer for season updates

async function updateAvailableSeasons() {
    const player1Name = document.getElementById('playerName').value.trim();
    const player2Name = document.getElementById('opponentName').value.trim();
    const seasonCheckboxes = document.getElementById('seasonCheckboxes');
    
    // Only fetch available seasons if both players are selected and detected
    if (!player1Name || !player2Name || !player1Type || !player2Type) {
        // Reset to show all seasons if players not selected
        initializeSeasonCheckboxes();
        return;
    }
    
    // Check for same type error - don't fetch seasons in this case
    if (player1Type === player2Type) {
        initializeSeasonCheckboxes();
        return;
    }
    
    // Clear any pending update
    if (seasonsUpdateTimeout) {
        clearTimeout(seasonsUpdateTimeout);
    }
    
    // Show loading state immediately when both players are detected
    seasonCheckboxes.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--color-text-secondary); font-style: italic;">Loading available seasons...</div>';
    
    // Fetch immediately - no debounce needed since we're checking for both types being detected
    // This ensures it updates as soon as the second player type is detected
    seasonsUpdateTimeout = setTimeout(async () => {
        try {
            // Determine role based on player 1's type
            const role = player1Type;
            
            // Double-check both types are still available (in case user changed inputs)
            const currentPlayer1Name = document.getElementById('playerName').value.trim();
            const currentPlayer2Name = document.getElementById('opponentName').value.trim();
            
            if (!currentPlayer1Name || !currentPlayer2Name || !player1Type || !player2Type) {
                return; // Don't update if inputs changed
            }
            
            const params = new URLSearchParams();
            params.append('player', currentPlayer1Name);
            params.append('opponent', currentPlayer2Name);
            params.append('role', role);
            
            const response = await fetch(`/api/matchups/seasons?${params}`);
            if (response.ok) {
                const data = await response.json();
                if (data.seasons && data.seasons.length > 0) {
                    initializeSeasonCheckboxes(data.seasons);
                } else {
                    // No matchup data found - show message instead of all seasons
                    seasonCheckboxes.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--color-text-secondary); font-style: italic;">No matchup data found between these players</div>';
                }
            } else {
                // Error fetching seasons - show message
                seasonCheckboxes.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--color-text-secondary); font-style: italic;">Unable to check available seasons</div>';
            }
        } catch (error) {
            console.warn('Error fetching available seasons:', error);
            // On error, show message
            seasonCheckboxes.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--color-text-secondary); font-style: italic;">Unable to check available seasons</div>';
        }
    }, 100); // Small 100ms delay to ensure state is settled, but fast enough to feel immediate
}

// Initialize season checkboxes
function initializeSeasonCheckboxes(availableSeasons = null) {
    const currentYear = {{ current_year }};
    const startYear = 2015;
    const seasonCheckboxes = document.getElementById('seasonCheckboxes');
    
    let seasonsToShow = [];
    
    if (availableSeasons && availableSeasons.length > 0) {
        // Only show seasons with available matchup data
        seasonsToShow = availableSeasons.filter(s => s >= startYear && s <= currentYear);
        // Sort descending (most recent first)
        seasonsToShow.sort((a, b) => b - a);
    } else {
        // Show all seasons from startYear to currentYear (most recent first)
        for (let year = currentYear; year >= startYear; year--) {
            seasonsToShow.push(year);
        }
    }
    
    // Generate checkboxes for each season
    let html = '';
    for (const year of seasonsToShow) {
        html += `
            <div class="season-checkbox-item">
                <input type="checkbox" id="season-${year}" value="${year}" class="season-checkbox">
                <label for="season-${year}" class="season-label">${year}</label>
            </div>
        `;
    }
    
    seasonCheckboxes.innerHTML = html;
    
    // Setup toggle all button
    setupToggleAllButton();
}

// Setup select all/deselect all button
function setupToggleAllButton() {
    const toggleBtn = document.getElementById('toggleAllSeasons');
    const checkboxes = document.querySelectorAll('.season-checkbox');
    
    if (!toggleBtn) return;
    
    // Update button text based on current state
    function updateButtonText() {
        const checkedCount = document.querySelectorAll('.season-checkbox:checked').length;
        const totalCount = checkboxes.length;
        
        if (checkedCount === totalCount) {
            toggleBtn.textContent = 'Deselect All';
        } else {
            toggleBtn.textContent = 'Select All';
        }
    }
    
    // Toggle all checkboxes
    toggleBtn.addEventListener('click', () => {
        const checkedCount = document.querySelectorAll('.season-checkbox:checked').length;
        const totalCount = checkboxes.length;
        const shouldSelectAll = checkedCount < totalCount;
        
        checkboxes.forEach(checkbox => {
            checkbox.checked = shouldSelectAll;
            // Trigger change event to update visual state
            checkbox.dispatchEvent(new Event('change'));
        });
        
        updateButtonText();
    });
    
    // Update button text when individual checkboxes change
    checkboxes.forEach(checkbox => {
        checkbox.addEventListener('change', updateButtonText);
    });
    
    // Initial button text update
    updateButtonText();
}

function updateRoleInfo() {
    const roleInfoDiv = document.getElementById('roleInfo');
    const roleInfoText = document.getElementById('roleInfoText');
    const roleErrorDiv = document.getElementById('roleError');
    
    // Hide both initially
    roleInfoDiv.style.display = 'none';
    roleErrorDiv.style.display = 'none';
    
    if (player1Type && player2Type) {
        const player1Name = document.getElementById('playerName').value || 'Player 1';
        const player2Name = document.getElementById('opponentName').value || 'Player 2';
        
        // Check for error: same types
        if (player1Type === player2Type) {
            roleErrorDiv.textContent = `Error: Both players are ${player1Type === 'pitcher' ? 'pitchers' : 'batters'}. Please select one batter and one pitcher.`;
            roleErrorDiv.style.display = 'block';
        }
        // Don't show roleInfo - it's not needed for user to see
    }
    // Don't show roleInfo for partial detection either - it's not needed
}

// Detect player types on input (with debounce)
let detectTimeout1 = null;
let detectTimeout2 = null;

// Setup Player 1 search
document.getElementById('playerName').addEventListener('input', (e) => {
    const searchTerm = e.target.value.trim();
    
    // Clear previous timeouts
    clearTimeout(player1SearchTimeout);
    clearTimeout(detectTimeout1);
    
    // Hide suggestions if input is empty
    const suggestionsDiv = document.getElementById('player1Suggestions');
    if (!searchTerm || searchTerm.length < 2) {
        if (suggestionsDiv) suggestionsDiv.style.display = 'none';
        player1Type = null;
        updateRoleInfo();
        return;
    }
    
    // Search for suggestions
    player1SearchTimeout = setTimeout(() => {
        searchPlayers1();
    }, 300);
    
    // Detect player type after a delay
    detectTimeout1 = setTimeout(() => {
        detectPlayerType(searchTerm, 1);
    }, 500);
});

// Setup Player 2 search
document.getElementById('opponentName').addEventListener('input', (e) => {
    const searchTerm = e.target.value.trim();
    
    // Clear previous timeouts
    clearTimeout(player2SearchTimeout);
    clearTimeout(detectTimeout2);
    
    // Hide suggestions if input is empty
    const suggestionsDiv = document.getElementById('player2Suggestions');
    if (!searchTerm || searchTerm.length < 2) {
        if (suggestionsDiv) suggestionsDiv.style.display = 'none';
        player2Type = null;
        updateRoleInfo();
        return;
    }
    
    // Search for suggestions
    player2SearchTimeout = setTimeout(() => {
        searchPlayers2();
    }, 300);
    
    // Detect player type after a delay
    detectTimeout2 = setTimeout(() => {
        detectPlayerType(searchTerm, 2);
    }, 500);
});

// Hide suggestions when clicking outside
document.addEventListener('click', (e) => {
    const player1Input = document.getElementById('playerName');
    const player1Suggestions = document.getElementById('player1Suggestions');
    const player2Input = document.getElementById('opponentName');
    const player2Suggestions = document.getElementById('player2Suggestions');
    
    if (player1Input && player1Suggestions && !player1Input.contains(e.target) && !player1Suggestions.contains(e.target)) {
        player1Suggestions.style.display = 'none';
    }
    
    if (player2Input && player2Suggestions && !player2Input.contains(e.target) && !player2Suggestions.contains(e.target)) {
        player2Suggestions.style.display = 'none';
    }
});

// Initialize season checkboxes on page load
document.addEventListener('DOMContentLoaded', () => {
    initializeSeasonCheckboxes();
});

document.getElementById('matchupForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const player1Name = document.getElementById('playerName').value.trim();
    const player2Name = document.getElementById('opponentName').value.trim();
    
    // Check if we need to detect types first
    if (!player1Type || !player2Type) {
        const errorDiv = document.getElementById('errorMessage');
        errorDiv.textContent = 'Please wait while we detect player types...';
        errorDiv.style.display = 'block';
        
        // Detect both types
        await Promise.all([
            detectPlayerType(player1Name, 1),
            detectPlayerType(player2Name, 2)
        ]);
    }
    
    // Check for same type error
    if (player1Type === player2Type) {
        const errorDiv = document.getElementById('errorMessage');
        errorDiv.textContent = `Error: Both players are ${player1Type === 'pitcher' ? 'pitchers' : 'batters'}. Please select one batter and one pitcher.`;
        errorDiv.style.display = 'block';
        return;
    }
    
    if (!player1Type || !player2Type) {
        const errorDiv = document.getElementById('errorMessage');
        errorDiv.textContent = 'Could not determine player types. Please check player names and try again.';
        errorDiv.style.display = 'block';
        return;
    }
    
    // Determine role based on player 1's type
    const role = player1Type; // 'pitcher' or 'batter'
    
    // Get selected seasons from checkboxes
    const selectedSeasons = Array.from(document.querySelectorAll('.season-checkbox:checked'))
        .map(cb => cb.value)
        .filter(val => val);
    
    const params = new URLSearchParams();
    params.append('player', player1Name);
    params.append('opponent', player2Name);
    params.append('role', role);
    
    // Add seasons - if multiple selected, pass all of them; if one, use season param; if none, API defaults to last 3 years
    if (selectedSeasons.length > 0) {
        if (selectedSeasons.length === 1) {
            params.append('season', selectedSeasons[0]);
        } else {
            // For multiple seasons, pass all selected seasons
            selectedSeasons.forEach(season => {
                params.append('seasons', season);
            });
        }
    }
    
    const resultsDiv = document.getElementById('results');
    const loadingDiv = document.getElementById('loading');
    const errorDiv = document.getElementById('errorMessage');
    const summarySection = document.getElementById('summarySection');
    const atBatsSection = document.getElementById('atBatsSection');
    const debugSection = document.getElementById('debugSection');
    
    resultsDiv.style.display = 'block';
    loadingDiv.style.display = 'block';
    errorDiv.style.display = 'none';
    summarySection.style.display = 'none';
    atBatsSection.style.display = 'none';
    debugSection.style.display = 'none';
    
    try {
        const response = await fetch(`/api/matchups?${params}`);
        const data = await response.json();
        
        loadingDiv.style.display = 'none';
        
        if (!response.ok) {
            errorDiv.textContent = data.error || 'Error fetching matchup data';
            errorDiv.style.display = 'block';
            return;
        }
        
        if (data.message) {
            errorDiv.textContent = data.message;
            errorDiv.style.display = 'block';
            return;
        }
        
        // Display summary
        if (data.summary && data.summary.total_at_bats > 0) {
            const summaryStats = document.getElementById('summaryStats');
            summaryStats.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${data.summary.total_at_bats}</div>
                    <div class="stat-label">At-Bats</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${data.summary.hits}</div>
                    <div class="stat-label">Hits</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${data.summary.average.toFixed(3)}</div>
                    <div class="stat-label">Average</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${data.summary.on_base_percentage.toFixed(3)}</div>
                    <div class="stat-label">OBP</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${data.summary.slugging_percentage.toFixed(3)}</div>
                    <div class="stat-label">SLG</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${data.summary.ops.toFixed(3)}</div>
                    <div class="stat-label">OPS</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${data.summary.home_runs}</div>
                    <div class="stat-label">Home Runs</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${data.summary.strikeouts}</div>
                    <div class="stat-label">Strikeouts</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${data.summary.walks}</div>
                    <div class="stat-label">Walks</div>
                </div>
            `;
            summarySection.style.display = 'block';
            
            // Display debug information if available
            if (data.summary && data.summary.debug) {
                const debugInfo = data.summary.debug;
                const debugDiv = document.getElementById('debugInfo');
                debugDiv.innerHTML = `
                    <div style="margin-bottom: 1rem;">
                        <strong>Calculated Totals:</strong><br>
                        • Total PA (including sac flies): ${debugInfo.calculated_pa}<br>
                        • Calculated AB: ${debugInfo.calculated_ab}<br>
                        • Hits: ${debugInfo.hits_count}<br>
                        • Outs: ${debugInfo.outs_count}<br>
                        • Walks: ${debugInfo.walks_count}<br>
                        • Sac Flies: ${debugInfo.sac_flies_count || 0}<br>
                        • Strikeouts: ${debugInfo.strikeouts_count}<br>
                        • Home Runs: ${debugInfo.home_runs_count}<br>
                        <br>
                        <strong>Verification Formula:</strong><br>
                        • ${debugInfo.verification_check || `AB (${debugInfo.calculated_ab}) + Walks (${debugInfo.walks_count}) + SF (${debugInfo.sac_flies_count || 0}) = ${debugInfo.calculated_ab + debugInfo.walks_count + (debugInfo.sac_flies_count || 0)} (should equal PA ${debugInfo.calculated_pa})`}<br>
                        • Hits + Outs = ${debugInfo.hits_count + debugInfo.outs_count} (should equal AB ${debugInfo.calculated_ab})<br>
                        ${debugInfo.deduplication_info && debugInfo.deduplication_info.duplicates_removed > 0 ? `
                        <br>
                        <strong style="color: #ff6b6b;">⚠️ DUPLICATE AT-BATS DETECTED:</strong><br>
                        • Before deduplication: ${debugInfo.deduplication_info.before_dedup} rows<br>
                        • After deduplication: ${debugInfo.deduplication_info.after_dedup} rows<br>
                        • Duplicates removed: ${debugInfo.deduplication_info.duplicates_removed}<br>
                        ` : ''}
                        ${debugInfo.duplicate_check && debugInfo.duplicate_check.total_unique_game_pk_at_bat_combos !== 'N/A' ? `
                        <br>
                        <strong>Duplicate Check:</strong><br>
                        • Unique game_pk + at_bat_number combinations: ${debugInfo.duplicate_check.total_unique_game_pk_at_bat_combos}<br>
                        • Total rows in pa_ending: ${debugInfo.duplicate_check.total_rows_in_pa_ending}<br>
                        ${debugInfo.duplicate_check.total_unique_game_pk_at_bat_combos !== debugInfo.duplicate_check.total_rows_in_pa_ending ? `
                        <span style="color: #ff6b6b;">⚠️ MISMATCH: ${debugInfo.duplicate_check.total_rows_in_pa_ending - debugInfo.duplicate_check.total_unique_game_pk_at_bat_combos} duplicate at-bats still present!</span><br>
                        ` : ''}
                        ` : ''}
                    </div>
                    ${Object.keys(debugInfo.categorized_breakdown || {}).length > 0 ? `
                    <div style="margin-bottom: 1rem;">
                        <strong>Event Breakdown:</strong><br>
                        ${Object.entries(debugInfo.categorized_breakdown).map(([category, events]) => `
                            <div style="margin-left: 1rem; margin-top: 0.5rem;">
                                <strong>${category.toUpperCase()}:</strong><br>
                                ${Object.entries(events).map(([event, count]) => `&nbsp;&nbsp;• ${event}: ${count}`).join('<br>')}
                            </div>
                        `).join('')}
                    </div>
                    ` : ''}
                    ${Object.keys(debugInfo.uncategorized_events || {}).length > 0 ? `
                    <div style="margin-bottom: 1rem; color: #ff6b6b;">
                        <strong>⚠️ UNCATEGORIZED EVENTS (These are NOT being counted in AB/PA):</strong><br>
                        ${Object.entries(debugInfo.uncategorized_events).map(([event, count]) => `• ${event}: ${count}`).join('<br>')}
                    </div>
                    ` : ''}
                    ${Object.keys(debugInfo.unique_events_raw || {}).length > 0 ? `
                    <div style="margin-bottom: 1rem;">
                        <strong>All Event Types Found (Raw Counts):</strong><br>
                        ${Object.entries(debugInfo.unique_events_raw).map(([event, count]) => `• ${event}: ${count}`).join('<br>')}
                    </div>
                    ` : ''}
                `;
                debugSection.style.display = 'block';
            }
        }
        
        // Pitch type name mapping
        const PITCH_NAME_MAP = {
            "FF": "Four-Seam",
            "FA": "Four-Seam",
            "FT": "Sinker",
            "SI": "Sinker",
            "ST": "Sweeper",
            "SL": "Slider",
            "FC": "Cutter",
            "CT": "Cutter",
            "CH": "Changeup",
            "CU": "Curveball",
            "KC": "Knuckle Curve",
            "CS": "Slurve",
            "FS": "Splitter",
            "FO": "Forkball",
            "SF": "Split-Finger",
            "KN": "Knuckleball",
            "EP": "Eephus"
        };
        
        function getPitchName(pitchType) {
            if (!pitchType) return 'Unknown';
            return PITCH_NAME_MAP[pitchType] || pitchType;
        }
        
        function formatPitchDescription(description) {
            if (!description) return '';
            // Capitalize first letter and make rest lowercase
            return description.charAt(0).toUpperCase() + description.slice(1).toLowerCase().replace(/_/g, ' ');
        }
        
        // Display at-bats
        if (data.matchups && data.matchups.length > 0) {
            const atBatsList = document.getElementById('atBatsList');
                atBatsList.innerHTML = data.matchups.map((ab, abIndex) => {
                const outcomeClass = getOutcomeClass(ab.outcome);
                const outcomeFormatted = formatOutcome(ab.outcome);
                const dateFormatted = formatDate(ab.game_date);
                
                // Helper function to get pitch type color (matching scouting report PDF colors)
                function getPitchTypeColor(pitchType) {
                    // Map full names to pitch type abbreviations, then to colors
                    const nameToAbbrev = {
                        'Four-Seam': 'FF',
                        'Sinker': 'SI',
                        'Sweeper': 'ST',
                        'Slider': 'SL',
                        'Cutter': 'FC',
                        'Changeup': 'CH',
                        'Curveball': 'CU',
                        'Knuckle Curve': 'KC',
                        'Slurve': 'SV',
                        'Splitter': 'FS',
                        'Split-Finger': 'FS',
                        'Forkball': 'FO',
                        'Knuckleball': 'KN',
                        'Eephus': 'EP',
                        'Two-Seam': 'FT',
                        'Screwball': 'SC',
                        'Slow Curve': 'CS'
                    };
                    
                    // Pitch type color map matching scouting reports (from build_bar_by_count.py)
                    const pitchColorMap = {
                        'FF': '#FF0000',   // Four-Seam - Red
                        'FT': '#8B0000',   // Two-Seam - Dark Red
                        'SI': '#FFA500',   // Sinker - Orange
                        'FC': '#808080',   // Cutter - Gray
                        'SL': '#0000FF',   // Slider - Blue
                        'CU': '#800080',   // Curveball - Purple
                        'SV': '#4682B4',   // Slurve - Steel Blue
                        'ST': '#008080',   // Sweeper - Teal
                        'CH': '#008000',   // Changeup - Green
                        'FS': '#00FFFF',   // Splitter - Cyan
                        'KC': '#4B0082',   // Knuckle Curve - Indigo
                        'KN': '#D3D3D3',   // Knuckleball - Light Gray
                        'EP': '#FFC0CB',   // Eephus - Pink
                        'FO': '#00008B',   // Forkball - Dark Blue
                        'SC': '#FF00FF',   // Screwball - Magenta
                        'CS': '#800000',   // Slow Curve - Maroon
                        'PO': '#A52A2A',   // Pitch Out - Brown
                        'IN': '#F0E68C',   // Intentional Ball - Khaki
                        'UN': '#B0C4DE'    // Unknown - Light Steel Blue
                    };
                    
                    // Convert full name to abbreviation if needed
                    const abbrev = nameToAbbrev[pitchType] || pitchType;
                    return pitchColorMap[abbrev] || '#B0C4DE'; // Default to light steel blue (Unknown)
                }
                
                // Helper function to render combined strike zone for all pitches
                function renderCombinedStrikeZone(pitches) {
                    if (!pitches || pitches.length === 0) {
                        return '<div class="strike-zone-missing">No pitch data</div>';
                    }
                    
                    // Filter pitches with location data
                    const pitchesWithLocation = pitches.filter(p => 
                        p.plate_x !== null && p.plate_x !== undefined && 
                        p.plate_z !== null && p.plate_z !== undefined
                    );
                    
                    if (pitchesWithLocation.length === 0) {
                        return '<div class="strike-zone-missing">No location data</div>';
                    }
                    
                    // Strike zone bounds (in feet): x from -0.85 to 0.85, z from 1.5 to 3.5
                    // Canvas coordinates: x from -2 to 2, z from 0 to 4
                    const xMin = -2;
                    const xMax = 2;
                    const zMin = 0;
                    const zMax = 4;
                    
                    // Strike zone bounds
                    const strikeZoneLeft = -0.85;
                    const strikeZoneRight = 0.85;
                    const strikeZoneBottom = 1.5;
                    const strikeZoneTop = 3.5;
                    
                    // Map to canvas coordinates (0-200 scale for better resolution)
                    const canvasWidth = 200;
                    const canvasHeight = 200;
                    
                    function xToCanvas(x) {
                        return ((x - xMin) / (xMax - xMin)) * canvasWidth;
                    }
                    
                    function zToCanvas(z) {
                        // Flip z-axis (y-axis in canvas) - 0 is bottom in plate_z but top in canvas
                        return ((zMax - z) / (zMax - zMin)) * canvasHeight;
                    }
                    
                    // Strike zone bounds in canvas coordinates
                    const szLeft = xToCanvas(strikeZoneLeft);
                    const szRight = xToCanvas(strikeZoneRight);
                    const szTop = zToCanvas(strikeZoneTop);
                    const szBottom = zToCanvas(strikeZoneBottom);
                    const szWidth = szRight - szLeft;
                    const szHeight = szBottom - szTop;
                    
                    // Generate pitch markers
                    const pitchMarkers = pitchesWithLocation.map((pitch, idx) => {
                        const pitchX = xToCanvas(pitch.plate_x);
                        const pitchZ = zToCanvas(pitch.plate_z);
                        const pitchType = getPitchName(pitch.pitch_type);
                        const color = getPitchTypeColor(pitchType);
                        const description = (pitch.description || '').toLowerCase();
                        
                        // Determine if swung at or taken
                        // Swung at: swinging strike, hit into play, foul
                        // Taken: ball, called strike
                        const isSwing = description.includes('swinging') || 
                                       description.includes('hit') || 
                                       description.includes('foul');
                        const isTake = !isSwing && (description.includes('ball') || 
                                                   description.includes('called'));
                        
                        // Fill if swung at, outline if taken
                        const fill = isSwing ? color : 'none';
                        const stroke = color;
                        const strokeWidth = isSwing ? 2.5 : 3;
                        const fillOpacity = isSwing ? 0.9 : 0;
                        const strokeOpacity = 0.95;
                        
                        // Determine if in strike zone
                        const inZone = pitch.plate_x >= strikeZoneLeft && 
                                     pitch.plate_x <= strikeZoneRight && 
                                     pitch.plate_z >= strikeZoneBottom && 
                                     pitch.plate_z <= strikeZoneTop;
                        
                        // Format metrics for tooltip
                        const formatMetric = (value, unit = '') => {
                            if (value === null || value === undefined) return 'N/A';
                            if (typeof value === 'number') {
                                if (unit === '°') {
                                    return value.toFixed(0) + unit;
                                }
                                return value.toFixed(1) + unit;
                            }
                            return value;
                        };
                        
                        // Format exit stats
                        const formatExitMetric = (value, unit = '') => {
                            if (value === null || value === undefined) return 'N/A';
                            if (typeof value === 'number') {
                                if (unit === '°') {
                                    return value.toFixed(1) + unit;
                                } else if (unit === ' ft') {
                                    return value.toFixed(0) + unit;
                                }
                                return value.toFixed(1) + unit;
                            }
                            return value;
                        };
                        
                        return {
                            x: pitchX,
                            z: pitchZ,
                            number: idx + 1,
                            color: color,
                            fill: fill,
                            stroke: stroke,
                            strokeWidth: strokeWidth,
                            fillOpacity: fillOpacity,
                            strokeOpacity: strokeOpacity,
                            inZone: inZone,
                            isSwing: isSwing,
                            velocity: formatMetric(pitch.velocity, ' mph'),
                            ivb: formatMetric(pitch.ivb, ' in'),
                            hvb: formatMetric(pitch.hvb, ' in'),
                            spin: formatMetric(pitch.spin, ' rpm'),
                            axis: formatMetric(pitch.axis, '°'),
                            pitchType: pitchType,
                            isHit: pitch.is_hit || false,
                            exitVelocity: formatExitMetric(pitch.exit_velocity, ' mph'),
                            launchAngle: formatExitMetric(pitch.launch_angle, '°'),
                            hitDistance: formatExitMetric(pitch.hit_distance, ' ft')
                        };
                    });
                    
                    // Build SVG with enhanced visuals
                    let svgContent = `
                        <svg class="combined-strike-zone" viewBox="0 0 ${canvasWidth} ${canvasHeight}" preserveAspectRatio="xMidYMid meet">
                            <!-- Background gradient -->
                            <defs>
                                <linearGradient id="strikeZoneGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" style="stop-color:var(--color-layer-base);stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:var(--color-layer-card);stop-opacity:1" />
                                </linearGradient>
                                <!-- Shadow filter removed -->
                            </defs>
                            
                            <!-- Strike zone grid (3x3) for reference -->
                            <g opacity="0.12">
                                ${(() => {
                                    let gridLines = '';
                                    const zoneWidth = szWidth / 3;
                                    const zoneHeight = szHeight / 3;
                                    for (let i = 1; i < 3; i++) {
                                        // Vertical lines
                                        gridLines += `<line x1="${szLeft + zoneWidth * i}" y1="${szTop}" x2="${szLeft + zoneWidth * i}" y2="${szBottom}" 
                                                  stroke="var(--color-text-secondary)" stroke-width="0.8"/>`;
                                        // Horizontal lines
                                        gridLines += `<line x1="${szLeft}" y1="${szTop + zoneHeight * i}" x2="${szRight}" y2="${szTop + zoneHeight * i}" 
                                                  stroke="var(--color-text-secondary)" stroke-width="0.8"/>`;
                                    }
                                    return gridLines;
                                })()}
                            </g>
                            
                            <!-- Strike zone outline with subtle background -->
                            <rect x="${szLeft - 1.5}" y="${szTop - 1.5}" width="${szWidth + 3}" height="${szHeight + 3}" 
                                  fill="rgba(255,255,255,0.03)" 
                                  stroke="var(--color-text-secondary)" 
                                  stroke-width="1" 
                                  opacity="0.15" 
                                  rx="3"/>
                            <rect x="${szLeft}" y="${szTop}" width="${szWidth}" height="${szHeight}" 
                                  fill="none" 
                                  stroke="var(--color-text-secondary)" 
                                  stroke-width="2" 
                                  opacity="0.4" 
                                  rx="2"/>
                            
                            <!-- Pitch markers -->
                    `;
                    
                    pitchMarkers.forEach((marker, idx) => {
                        // Draw pitch location circle with cleaner styling and hover data
                        const circleId = `pitch-circle-${idx}`;
                        const tooltipId = `pitch-tooltip-${idx}`;
                        
                        // For unfilled balls (outlined), add an invisible larger circle for better hover detection
                        const hoverRadius = marker.fill === 'none' ? 15 : 10; // Larger hover area for outlined balls
                        const hoverFill = marker.fill === 'none' ? 'transparent' : marker.fill;
                        
                        svgContent += `
                            <!-- Main pitch circle with hover -->
                            <g class="pitch-marker-group" data-pitch-index="${idx}">
                                <!-- Invisible hover area (larger for outlined balls) -->
                                <circle id="${circleId}-hover" 
                                        cx="${marker.x}" 
                                        cy="${marker.z}" 
                                        r="${hoverRadius}" 
                                        fill="${hoverFill}" 
                                        opacity="0"
                                        style="cursor: pointer; pointer-events: all;"
                                        data-velocity="${marker.velocity}"
                                        data-ivb="${marker.ivb}"
                                        data-hvb="${marker.hvb}"
                                        data-spin="${marker.spin}"
                                        data-axis="${marker.axis}"
                                        data-pitch-type="${marker.pitchType}"
                                        data-is-hit="${marker.isHit || false}"
                                        data-exit-velocity="${marker.exitVelocity || 'N/A'}"
                                        data-launch-angle="${marker.launchAngle || 'N/A'}"
                                        data-hit-distance="${marker.hitDistance || 'N/A'}"/>
                                <!-- Visible pitch circle -->
                                <circle id="${circleId}" 
                                        cx="${marker.x}" 
                                        cy="${marker.z}" 
                                        r="10" 
                                        fill="${marker.fill}" 
                                        stroke="${marker.stroke}" 
                                        stroke-width="${marker.strokeWidth}" 
                                        fill-opacity="${marker.fillOpacity}"
                                        stroke-opacity="${marker.strokeOpacity}"
                                        style="pointer-events: none;"
                                        data-velocity="${marker.velocity}"
                                        data-ivb="${marker.ivb}"
                                        data-hvb="${marker.hvb}"
                                        data-spin="${marker.spin}"
                                        data-axis="${marker.axis}"
                                        data-pitch-type="${marker.pitchType}"
                                        data-is-hit="${marker.isHit || false}"
                                        data-exit-velocity="${marker.exitVelocity || 'N/A'}"
                                        data-launch-angle="${marker.launchAngle || 'N/A'}"
                                        data-hit-distance="${marker.hitDistance || 'N/A'}"/>
                                <!-- Pitch number -->
                                <text x="${marker.x}" 
                                      y="${marker.z + 3.5}" 
                                      text-anchor="middle" 
                                      font-size="9.5" 
                                      font-weight="700"
                                      font-family="system-ui, -apple-system, sans-serif"
                                      fill="${marker.isSwing ? 'white' : marker.stroke}"
                                      dominant-baseline="middle"
                                      stroke="${marker.isSwing ? 'rgba(0,0,0,0.3)' : 'var(--color-text-secondary)'}"
                                      stroke-width="${marker.isSwing ? '0.6' : '1'}"
                                      paint-order="stroke fill"
                                      pointer-events="none">${marker.number}</text>
                            </g>
                        `;
                    });
                    
                    svgContent += '</svg>';
                    
                    // Wrap in a div with tooltip container
                    const wrapperId = `strike-zone-wrapper-${Date.now()}`;
                    return `
                        <div class="strike-zone-wrapper" id="${wrapperId}">
                            ${svgContent}
                            <div class="pitch-tooltip" id="pitch-tooltip-${wrapperId}"></div>
                        </div>
                    `;
                }
                
                // Build pitches list with narrative flow
                const pitchesHtml = ab.pitches && ab.pitches.length > 0 ? ab.pitches.map((pitch, idx) => {
                    const count = `${pitch.balls || 0}-${pitch.strikes || 0}`;
                    const pitchType = getPitchName(pitch.pitch_type);
                    const description = formatPitchDescription(pitch.description);
                    const isLastPitch = idx === ab.pitches.length - 1;
                    const isFullCount = (pitch.balls || 0) === 3 && (pitch.strikes || 0) === 2;
                    
                    // Generate video URL - use playId (UUID) for Baseball Savant if available, otherwise fallback to Gameday
                    let videoUrl;
                    if (pitch.play_id) {
                        // Use Baseball Savant with playId UUID for direct pitch video
                        videoUrl = `https://baseballsavant.mlb.com/sporty-videos?playId=${pitch.play_id}`;
                    } else {
                        // Fallback: Try to use a better Gameday URL format
                        // Use the play index in the sequence instead of just at_bat_number
                        // Note: This may still redirect, but it's the best we can do without playId
                        const pitchIndexInAtBat = idx; // Index of pitch in this at-bat's sequence
                        videoUrl = `https://www.mlb.com/gameday/${ab.game_pk}#/play/${ab.at_bat_number}/${pitchIndexInAtBat}`;
                        console.warn(`No play_id for pitch ${pitch.pitch_number || idx + 1} in at-bat ${ab.at_bat_number}, using fallback URL`);
                    }
                    
                    // Determine description color based on outcome
                    let descClass = 'pitch-description';
                    if (description.toLowerCase().includes('strike') || description.toLowerCase().includes('swinging')) {
                        descClass += ' pitch-strike';
                    } else if (description.toLowerCase().includes('ball')) {
                        descClass += ' pitch-ball';
                    } else if (description.toLowerCase().includes('hit') || description.toLowerCase().includes('foul')) {
                        descClass += ' pitch-contact';
                    }
                    
                    return `
                        <div class="pitch-step ${isLastPitch ? 'pitch-final' : ''} ${isFullCount ? 'pitch-full-count' : ''}">
                            <div class="pitch-number">Pitch ${idx + 1}</div>
                            <div class="pitch-count-badge ${isFullCount ? 'count-full' : ''}">${count}</div>
                            <div class="pitch-info">
                                <span class="pitch-type">${pitchType}</span>
                                ${description ? `<span class="${descClass}">${description}</span>` : ''}
                                ${isLastPitch ? `<div class="pitch-outcome-badge ${outcomeClass}">${outcomeFormatted}</div>` : ''}
                            </div>
                            <a href="${videoUrl}" target="_blank" rel="noopener noreferrer" class="pitch-video-link" title="Watch pitch video">
                                <i class="fas fa-video"></i>
                            </a>
                        </div>
                    `;
                }).join('') : '<div class="pitch-item">No pitch data available</div>';
                
                // Render combined strike zone for all pitches
                const combinedStrikeZone = renderCombinedStrikeZone(ab.pitches || []);
                
                return `
                    <div class="at-bat-card">
                        <div class="at-bat-header">
                            <div class="at-bat-meta">
                                <span class="at-bat-date">${dateFormatted}</span>
                                <span class="at-bat-number">At-Bat #${ab.player_at_bat_number || ab.at_bat_number}</span>
                            </div>
                        </div>
                        <div class="pitches-visualization">
                            <div class="pitches-timeline">
                                <div class="timeline-label">Pitch Sequence</div>
                                <div class="pitches-sequence">
                                    ${pitchesHtml}
                                </div>
                            </div>
                            <div class="strike-zone-container">
                                <div class="strike-zone-label">Pitch Locations</div>
                                ${combinedStrikeZone}
                                <div class="strike-zone-legend">
                                    <div class="strike-zone-legend-item">
                                        <div class="strike-zone-legend-circle filled"></div>
                                        <span>Swing</span>
                                    </div>
                                    <div class="strike-zone-legend-item">
                                        <div class="strike-zone-legend-circle outlined"></div>
                                        <span>Take</span>
                                    </div>
                                </div>
                                <div class="strike-zone-pov">Hitter's POV</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            atBatsSection.style.display = 'block';
            
            // Attach hover tooltip handlers to pitch circles
            setTimeout(() => {
                document.querySelectorAll('.strike-zone-wrapper').forEach(wrapper => {
                    const tooltip = wrapper.querySelector('.pitch-tooltip');
                    const svg = wrapper.querySelector('svg');
                    if (!tooltip || !svg) return;
                    
                    // Get SVG bounding box for coordinate conversion
                    const svgRect = svg.getBoundingClientRect();
                    const viewBox = svg.viewBox.baseVal;
                    
                    // Use the hover circle (invisible larger area) for event handling
                    svg.querySelectorAll('.pitch-marker-group circle[id$="-hover"]').forEach(circle => {
                        circle.addEventListener('mouseenter', (e) => {
                            const velocity = circle.getAttribute('data-velocity') || 'N/A';
                            const ivb = circle.getAttribute('data-ivb') || 'N/A';
                            const hvb = circle.getAttribute('data-hvb') || 'N/A';
                            const spin = circle.getAttribute('data-spin') || 'N/A';
                            const axis = circle.getAttribute('data-axis') || 'N/A';
                            const pitchType = circle.getAttribute('data-pitch-type') || 'Unknown';
                            const isHit = circle.getAttribute('data-is-hit') === 'true';
                            const exitVelocity = circle.getAttribute('data-exit-velocity') || 'N/A';
                            const launchAngle = circle.getAttribute('data-launch-angle') || 'N/A';
                            const hitDistance = circle.getAttribute('data-hit-distance') || 'N/A';
                            const exitSpin = circle.getAttribute('data-exit-spin') || 'N/A';
                            
                            // Build tooltip HTML - show exit stats if ball was hit into play
                            let tooltipContent = `
                                <div class="pitch-tooltip-header">${pitchType}</div>
                                <div class="pitch-tooltip-metric">
                                    <span class="pitch-tooltip-label">Velo:</span>
                                    <span class="pitch-tooltip-value">${velocity}</span>
                                </div>
                                <div class="pitch-tooltip-metric">
                                    <span class="pitch-tooltip-label">IVB:</span>
                                    <span class="pitch-tooltip-value">${ivb}</span>
                                </div>
                                <div class="pitch-tooltip-metric">
                                    <span class="pitch-tooltip-label">HVB:</span>
                                    <span class="pitch-tooltip-value">${hvb}</span>
                                </div>
                                <div class="pitch-tooltip-metric">
                                    <span class="pitch-tooltip-label">Spin:</span>
                                    <span class="pitch-tooltip-value">${spin}</span>
                                </div>
                                <div class="pitch-tooltip-metric">
                                    <span class="pitch-tooltip-label">Axis:</span>
                                    <span class="pitch-tooltip-value">${axis}</span>
                                </div>
                            `;
                            
                            // Add exit stats section if ball was hit into play
                            if (isHit && exitVelocity !== 'N/A') {
                                tooltipContent += `
                                    <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid var(--color-layer-border);">
                                        <div class="pitch-tooltip-header" style="margin-bottom: 0.5rem;">Exit Stats</div>
                                        <div class="pitch-tooltip-metric">
                                            <span class="pitch-tooltip-label">Exit Velo:</span>
                                            <span class="pitch-tooltip-value">${exitVelocity}</span>
                                        </div>
                                        <div class="pitch-tooltip-metric">
                                            <span class="pitch-tooltip-label">Launch Angle:</span>
                                            <span class="pitch-tooltip-value">${launchAngle}</span>
                                        </div>
                                        <div class="pitch-tooltip-metric">
                                            <span class="pitch-tooltip-label">Distance:</span>
                                            <span class="pitch-tooltip-value">${hitDistance}</span>
                                        </div>
                                    </div>
                                `;
                            }
                            
                            tooltip.innerHTML = tooltipContent;
                            
                            // Position tooltip near the circle
                            const cx = parseFloat(circle.getAttribute('cx'));
                            const cy = parseFloat(circle.getAttribute('cy'));
                            
                            // Convert SVG coordinates to screen coordinates
                            const xPercent = (cx / viewBox.width);
                            const yPercent = (cy / viewBox.height);
                            const wrapperRect = wrapper.getBoundingClientRect();
                            const xPos = wrapperRect.left + (svgRect.width * xPercent);
                            const yPos = wrapperRect.top + (svgRect.height * yPercent);
                            
                            // Position tooltip to the right of the circle, or left if too close to right edge
                            const tooltipWidth = 180;
                            const tooltipHeight = isHit && exitVelocity !== 'N/A' ? 220 : 160; // Taller if exit stats are shown
                            let tooltipX = xPos + 15;
                            let tooltipY = yPos - tooltipHeight / 2;
                            
                            // Adjust if tooltip would go off screen
                            if (tooltipX + tooltipWidth > window.innerWidth - 20) {
                                tooltipX = xPos - tooltipWidth - 15;
                            }
                            if (tooltipY + tooltipHeight > window.innerHeight - 20) {
                                tooltipY = window.innerHeight - tooltipHeight - 20;
                            }
                            if (tooltipY < 20) {
                                tooltipY = 20;
                            }
                            
                            tooltip.style.left = tooltipX + 'px';
                            tooltip.style.top = tooltipY + 'px';
                            tooltip.classList.add('show');
                            
                            // Add hover effect - increase visible circle size
                            const visibleCircle = circle.parentElement.querySelector(`circle:not([id$="-hover"])`);
                            if (visibleCircle) {
                                const currentR = parseFloat(visibleCircle.getAttribute('r'));
                                visibleCircle.setAttribute('r', currentR + 2);
                            }
                        });
                        
                        circle.addEventListener('mouseleave', () => {
                            tooltip.classList.remove('show');
                            // Reset visible circle size
                            const visibleCircle = circle.parentElement.querySelector(`circle:not([id$="-hover"])`);
                            if (visibleCircle) {
                                visibleCircle.setAttribute('r', '10');
                            }
                        });
                    });
                });
            }, 100);
        } else {
            errorDiv.textContent = 'No at-bats found';
            errorDiv.style.display = 'block';
        }
        
    } catch (error) {
        loadingDiv.style.display = 'none';
        errorDiv.textContent = 'Error: ' + error.message;
        errorDiv.style.display = 'block';
    }
});
</script>
{% endblock %}


